use crate::traits::DatabaseEntry;

/// Marker trait for cache implementations used by [`Database`](crate::Database).
///
/// A `Cache` is associated with a specific [`Manifest`](crate::Manifest) via the `Manifest`
/// associated type, allowing the database to enforce that the cache was generated for the
/// correct schema. Use [`NoCache`] as a default no-op implementation when caching is not needed.
///
/// Implement this trait via the `manifest!` macro using the `+` syntax:
///
/// ```rust,ignore
/// manifest![MyManifest + MyHashMap: RecordA, RecordB];
/// // generates MyManifestCache which implements Cache<Manifest = MyManifest>
/// ```
pub trait Cache: Default {
    /// The [`Manifest`](crate::Manifest) this cache was generated for.
    ///
    /// For [`NoCache`] this is `()`. For a generated cache struct `FooCache` this will be `Foo`.
    type Manifest;
}

/// A no-op [`Cache`] implementation that performs no caching.
///
/// This is the default cache type for [`Database`](crate::Database). All operations are
/// pass-throughs — reads always miss and writes are silently discarded.
#[derive(Default)]
pub struct NoCache;

impl Cache for NoCache {
    type Manifest = ();
}

impl<K, V> CacheContainer<K, V> for NoCache {
    fn set(&mut self, _key: &K, _value: &V) {}
    fn get(&mut self, _key: &K) -> Option<V> {
        None
    }
    fn expire(&mut self, _key: &K) {}
}

impl<T: DatabaseEntry> CacheAccess<T> for NoCache {
    type Container = NoCache;
    fn access(&mut self) -> &mut NoCache {
        self
    }
}

/// A key-value cache store for a single record type.
///
/// Implementations hold cached values of type `V` keyed by `K`. The database calls these methods
/// around storage operations to keep the cache consistent:
///
/// - [`set`](CacheContainer::set) — populate the cache after a successful read.
/// - [`get`](CacheContainer::get) — check the cache before hitting storage.
/// - [`expire`](CacheContainer::expire) — invalidate an entry after a write or removal.
pub trait CacheContainer<K, V> {
    /// Insert or update the cached value for `key`.
    fn set(&mut self, key: &K, value: &V);

    /// Return the cached value for `key`, or `None` on a cache miss.
    fn get(&mut self, key: &K) -> Option<V>;

    /// Remove the cached value for `key`, forcing the next read to go to storage.
    fn expire(&mut self, key: &K);
}

/// Provides access to the [`CacheContainer`] responsible for a specific [`DatabaseEntry`] type.
///
/// A cache struct generated by `manifest![Name + CacheType: ...]` implements this trait once for
/// each entry type listed in the manifest, delegating to the corresponding field of the struct.
/// [`NoCache`] implements it for every `T` by returning itself.
pub trait CacheAccess<T: DatabaseEntry> {
    /// The concrete [`CacheContainer`] that stores values of type `T`.
    type Container: CacheContainer<<T as DatabaseEntry>::Key, T>;

    /// Return a mutable reference to the container for entry type `T`.
    fn access(&mut self) -> &mut Self::Container;
}
