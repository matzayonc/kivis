use std::any::TypeId;
use std::collections::HashMap;
use std::marker::PhantomData;

use crate::{
    Database, DatabaseEntry, DatabaseError, DeserializationError, Incrementable, KeyBytes,
    Manifest, Manifests, RecordKey, Storage,
};

/// A struct that preloads and caches the last IDs for all tables in a manifest.
/// This eliminates the need for database reads during `put` operations to determine the next ID.
pub struct TableHeads<M: Manifest> {
    /// Maps TypeId of record types to their current last ID as raw bytes
    last_ids: HashMap<TypeId, Vec<u8>>,
    _phantom: PhantomData<M>,
}

impl<M: Manifest> TableHeads<M> {
    /// Creates a new `TableHeads` instance and loads all current last IDs from the database.
    pub fn new<S: Storage>(
        database: &Database<S, M>,
    ) -> Result<Self, DatabaseError<S::StoreError>> {
        let mut table_heads = Self {
            last_ids: HashMap::new(),
            _phantom: PhantomData,
        };

        // This will be expanded by a macro or filled in by implementing types
        table_heads.load_all_heads(database)?;
        Ok(table_heads)
    }

    /// Loads the last ID for a specific record type.
    pub fn load_head<R, S>(
        &mut self,
        database: &Database<S, M>,
    ) -> Result<(), DatabaseError<S::StoreError>>
    where
        R: DatabaseEntry + 'static,
        R::Key: RecordKey<Record = R> + Incrementable + Ord + KeyBytes,
        M: Manifests<R>,
        S: Storage,
    {
        let last_id = Self::last_id::<R::Key, S>(database)?;
        let serialized_id = last_id.to_bytes(database.serialization_config());

        self.last_ids.insert(TypeId::of::<R>(), serialized_id);
        Ok(())
    }

    /// Gets the next ID for a specific record type without requiring a database read.
    pub fn next_id<R>(&mut self) -> Result<R::Key, TableHeadsError>
    where
        R: DatabaseEntry + 'static,
        R::Key: RecordKey<Record = R> + Incrementable + Ord + KeyBytes,
        M: Manifests<R>,
    {
        let type_id = TypeId::of::<R>();
        let serialized_id = self
            .last_ids
            .get(&type_id)
            .ok_or(TableHeadsError::TypeNotLoaded)?;

        // Deserialize the current last ID using configuration from the storage
        let current_id = R::Key::from_bytes(serialized_id, bincode::config::standard())?;

        // Get the next ID
        let next_id = current_id
            .next_id()
            .ok_or(TableHeadsError::IncrementOverflow)?;

        // Update our cached value
        let new_serialized = next_id.to_bytes(bincode::config::standard());
        self.last_ids.insert(type_id, new_serialized);

        Ok(next_id)
    }

    /// Refreshes the last ID for a specific record type by querying the database.
    /// This is useful if records were added outside of this `TableHeads` instance.
    pub fn refresh_head<R, S>(
        &mut self,
        database: &Database<S, M>,
    ) -> Result<(), DatabaseError<S::StoreError>>
    where
        R: DatabaseEntry + 'static,
        R::Key: RecordKey<Record = R> + Incrementable + Ord + KeyBytes,
        M: Manifests<R>,
        S: Storage,
    {
        self.load_head::<R, S>(database)
    }

    /// Refreshes all loaded heads by querying the database.
    pub fn refresh_all_heads<S: Storage>(
        &mut self,
        _database: &Database<S, M>,
    ) -> Result<(), DatabaseError<S::StoreError>> {
        // We need to know which types were loaded to refresh them
        // This is a limitation - we can't refresh types we don't know about
        // The user will need to call refresh_head for each type manually
        // or we could store type information differently
        Ok(())
    }

    /// Private method to load all heads. This will need to be implemented
    /// by users or through macro generation for each manifest.
    fn load_all_heads<S: Storage>(
        &mut self,
        _database: &Database<S, M>,
    ) -> Result<(), DatabaseError<S::StoreError>> {
        // This is intentionally empty - users need to call load_head for each type
        // they want to preload, or this could be generated by a macro
        Ok(())
    }

    /// Helper function to get the last ID in a given range, used for autoincrementing keys.
    pub fn last_id<K: RecordKey + Ord + Default, S: Storage>(
        database: &Database<S, M>,
        // bounds: (K, K),
    ) -> Result<K, DatabaseError<S::StoreError>>
    where
        K::Record: DatabaseEntry<Key = K>,
        M: Manifests<K::Record>,
    {
        // let (start, end) = bounds;
        // let range = if start < end {
        //     start.clone()..end
        // } else {
        //     end..start.clone()
        // };
        // let mut first = database.iter_keys::<K>(range)?;
        let mut first = database.iter_all_keys::<K>()?;

        Ok(first.next().transpose()?.unwrap_or_default())
    }
}

/// Errors that can occur when using `TableHeads`.
#[derive(Debug)]
pub enum TableHeadsError {
    TypeNotLoaded,
    IncrementOverflow,
    Deserialization(DeserializationError),
}

impl From<DeserializationError> for TableHeadsError {
    fn from(e: DeserializationError) -> Self {
        TableHeadsError::Deserialization(e)
    }
}

impl std::fmt::Display for TableHeadsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::TypeNotLoaded => write!(f, "Record type not loaded in TableHeads"),
            Self::IncrementOverflow => write!(f, "Failed to increment ID - overflow occurred"),
            Self::Deserialization(e) => write!(f, "Failed to deserialize ID: {:?}", e),
        }
    }
}

impl std::error::Error for TableHeadsError {}
